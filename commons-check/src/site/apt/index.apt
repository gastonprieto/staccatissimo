About Staccato-Commons-Check
 
 Staccato-Commons-Check is the validation library of the {{{http://staccatocommons.sourceforge.net}Staccato-Commons project}}. 
It offers classes for performing flexible, generic preconditions and postconditions and domain-specific validations. 

 Please notice Staccato-Commons-Check is a validation API targeted for implementing fail-fast programming, like validation 
classes you can find in {{{http://commons.apache.org/lang/}Apache Commons Lang}}
or {{{http://code.google.com/p/guava-libraries/}Guava}}. It is by no means a conversion and validation 
API like {{{http://commons.apache.org/validator/}Apache Commons Validator}}    
 
Alpha state 

 Staccato-Commons-Check is currently in alpha state.
  Although most of previous features are implemented, tested and documented, it should not be used in productive systems yet. 
 
Getting started
 
 Staccato-Commons-Check is a validation API designed for being rich, easy to use, flexible, extensible, and general purpose. Its core is
 the <<<net.sf.staccatocommons.check.Check\<E\>>>> class. It implements more than 40 common checks with automatic
error messages building, in a method-chaining fashion. 

 Lets see how it works with an example:
 suppose we are implementing a juice recipes system, that can produce juice given its ingredients. In particular, we are now implementing 
a TropicalJuiceRecipe, based on bananas and pineapples. We are going to inject dependencies through constructor, so our recipe will look
like the following:

+---
 class TropicalJuiceRecipe implements JuiceRecipe {

    private final int suger;
    private final OrangeJuice juice;
    private final Collection<Banana> bananas;
    private final Collection<Pineapple> pineapples;

    /**
     * 
     * Creates a new {@link TropicalJuiceRecipe}
     * 
     * It takes orange juice, some sugar, some bananas and at least 2 pinaples.
     * 
     * Juice must not have expired and that it must not be too acid.
     */
    public TropicalJuiceRecipe(int sugar, OrangeJuice juice, Collection<Banana> bananas,
        Collection<Pineapple> pineapples) {
        this.suger = sugar;
        this.juice = juice;
        this.bananas = bananas;
        this.pineapples = pineapples;

    }

    public Juice prepare() {
        // Don't care....
        return null;
    }
}

+----

 As you see in the constructor Javadoc, our recipe has some constraints regarding its input ingredients, 
 such restrictions are called preconditions. 
 Our recipe will not work unless they are meet, so it is good practice to check them as soon as possible, and fail fast, if necessary. 
 So just add the preconditions check, our constructor will look like the following:
 
+-----


  /**
     * 
     * Creates a new {@link TropicalJuiceRecipe}
     * 
     * It takes orange juice, some sugar, some bananas and at least 2 pinaples.
     * 
     * Juice must not have expired and that it must not be too acid.
     */
    public TropicalJuiceRecipe(int sugar, OrangeJuice juice, Collection<Banana> bananas,
        Collection<Pineapple> pineapples) {
        if (juice == null)
            throw new IllegalArgumentException("juice must not be null");

        if (!juice.isNotTooAcid())
            throw new IllegalArgumentException("juice.isNotTooAcide must not be true");

        if (juice.getExpirationDate().compareTo(new Date()) >= 0)
            throw new IllegalArgumentException("juice.expirationDate must be greater than today");

        if (sugar <= 0)
            throw new IllegalArgumentException("sugar must be be greather than zero");

        if (bananas == null)
            throw new IllegalArgumentException("bananas must not be null");

        if (bananas.isEmpty())
            throw new IllegalArgumentException("bananas must not be empty");

        if (pineapples == null)
            throw new IllegalArgumentException("pineapples must be null");

        if (pineapples.size() < 2)
            throw new IllegalArgumentException("pineapples must be of at least size 2");
            
        this.suger = sugar;
        this.juice = juice;
        this.bananas = bananas;
        this.pineapples = pineapples;

    }
+----- 
 
  All such checks are necessary, but boilerplate, code. We are forced to manually write each condition, negating them,
  generating a message, and throwing an exception. It works, but is not the Panacea.
  
  Here is where Staccato-Commons-Check comes to rescue:
  
  
+---
    /**
     * 
     * Creates a new {@link TropicalJuiceRecipe}
     * 
     * It takes orange juice, some sugar, some bananas and at least 2 pinaples.
     * 
     * Juice must not have expired and that it must not be too acid.
     */
    public TropicalJuiceRecipe2(int sugar, OrangeJuice juice, Collection<Banana> bananas,
        Collection<Pineapple> pineapples) {
        Ensure
            .that()
            .isTrue("juice.notTooAcid", juice.isNotTooAcid())
            .isGreaterThan("juice.expirationDate", juice.getExpirationDate(), new Date())
            .isPositive("sugar", sugar)
            .isNotEmpty("bananas", bananas)
            .isMinSize("pineapples", pineapples, 2);
        this.suger = sugar;
        this.juice = juice;
        this.bananas = bananas;
        this.pineapples = pineapples;
    }
+---         

TODO.......


 All automatic check methods take at least two arguments: a mnemonic for the object - normally the variable 
 or attribute name - and the object to check. It is not necessary to pass any extra message, as all the invocation have enough information
 to generate them.

 In addition to those checks, it offers general boolean condition tests and forced failures methods. For example:

+---- 
check.that(account.hasEnoughFonds(),  "Account %s must have enough fonds", account);
  
check.failure("Code should not have reached here");
+--- 
 
 Those methods take at least a message argument, as they have no enough information to construct one.  
 
 <<<Check>>> class, however, is abstract, and does not define the specific exception to be thrown on failure.  
It is parameterized instead by the exception type it throws, and is responsibility of subclasses to define that.

 To address that, the API provides three concrete implementations of <<<Check>>>:
 
 * Ensure's: throws <<<java.lang.IllegalArgumentException>>>, and is used to check generic preconditions. 
 A reference to it can be obtained through the <<<Ensure>>> utility class:
   
+-----
Ensure.that()
    .isNotEmpty("bananas", bananas)
    .isMinSize("pineapples", pineapples, 2);
+----- 
 
 It offers also some class method shortcuts to the most frequent checks:
 
+----
Ensure.isNotNull("jukebox", jukebox);
+---- 
 
 * Assert's: Throws <<<java.lang.AssertionError>>>, and is used to check generic postconditions and invariants. There exists
 an <<<Assert>>> utility class, similar to the <<<Ensure>>>. 
 
 * Validate's: Throws exceptions of any given type - in particular, they do not need to be <<<java.lang.RuntimeException>>>s.
It is used to perform domain specific validations. Instances of it can be created through <<<Validate.throwing(Class)>>> class method:

+----
 Validate.throwing(PhoneCallException.class)
    .that(!line.isBuys(), "The line %s must not be busy", line)
    .that(destination.isReachable(), "The destination %s is unreachable", destination); 
+----   
   
What is next?

 * Navigate the {{{http://staccatocommons.sourceforge.net/staccatissimo/commonscheck/apidocs/index.html}API javadoc}}
 
 * Explore the rest of Staccato-Commons projects. They extensively use Staccato-Commons-Check
 
 * Have a look to the {{{http://staccatocommons.sourceforge.net/staccatissimo/commonsrestrictionsinstrument/}Staccato-Commons-Restricions-Instrument}} API,
which instrument check annotations, by inserting at compile time calls
to the Validation API previously described.      

Road map

 Staccato-Commons-Check is in continuous development. Next releases are focused on augmenting extensibility and richness of both APIs.