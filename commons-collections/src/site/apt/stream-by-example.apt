Stream by example

* Introduction 
 
 Streams are potentially infinite iterable objects that have a very rich interface and
  perform most operations in a lazy manner and functional style.
  They are designed to make complex, lazy transformations on iterable 
  or iterable-like objects easier. Although they are primary targeted for dealing with collections, other Staccato-Commons
  projects offer other alternative implementations that extend their scope.  
  
  On the other hand, for performing simple, eager transformations on just iterables, eventually in a more imperative style, 
 have a look at {{{iterables-by-example.html}Iterables by example}}.
  
* The problem
  
  Quite frequently, developers need to perform in-memory complex, chained transformations over collections, like selecting,
  filtering or mapping elements. In Java, without any support for those operation neither at language nor standard library level, 
  developers have usually to implement them writing ad-hoc methods. Code like the following is far too common:
  
+---
   Collection<Incident> getMostUrgentProblems() {
        List<Incident> incidents = new ArrayList<Incident>();
        for (Service service : services) {
            if (service.isDown()) {
                incidents.add(service.getMostRecentIncident());
            }
        }
        Collections.sort(incidents, new Comparator<Incident>() {
            public int compare(Incident arg0, Incident arg1) {
                return arg0.getPriority() - arg1.getPriority();
            }
        });
        if (incidents.size() > 5) {
            for (Iterator<Incident> iter = incidents.listIterator(5); iter.hasNext();) {
                iter.next();
                iter.remove();
            }
        }
        return incidents;
    }
+--- 
 
  The problem of such code is that it is reinventing the wheel, mixing different transformations in one.  In this case, developer is
  filtering down services, mapping their most recent incidents, and getting top 5 most urgent issues by priority - 4 operations 
  that need to be coded, tested, and probably debugged. 
  
  Fortunately, many Java frameworks exists that attack those problems, each one with its pros and cons:
   {{{http://commons.apache.org/collections/}Apache Commons Collections}}, 
  {{{http://code.google.com/p/guava-libraries/}Guava (formerly Google Collections)}},
   {{{http://code.google.com/p/totallylazy/}TotallyLazy}},
  {{{http://functionaljava.org/}FunctionalJava}}, 
  {{{http://www.op4j.org/}Op4J}}, {{{http://quaere.codehaus.org/}Quaere}} 
  and of course, Staccato-Commons-Collections.
  
  It is not our intention to make a comparison between all those frameworks.
  As said before, all them have both strengths and flaws, and the developer should decide which fits better. 
  Instead, we will just present the solutions Staccato-Commons-Collections offers.
  
  
  
* The Solution

 Streams are the Staccato-Commons solution for performing such operations on iterables. They are generic wrappers that implement many of those
common transformation in a lazy manner - that is, no processing is actually performed in most cases unless it it actually necessary, which
enables them to perform efficiently chained operations on demand on both small and very large sequences of elements. They can be constructed  
literally by specifying their elements (Cons utility class), by specifying the elements generation strategy (Iterate utility class), 
by decorating other Iterables (Streams utility class) or using sources like databases result sets, directories, files, etc
 (provided by the rest of Staccato-Commons projects). 
 
 For example, the previous code can be refactored to use Streams:

+----
    Collection<Incident> getMostUrgentProblems2() {
        return Streams.from(services).filter(new Predicate<Service>() {
            public boolean eval(Service argument) {
                return argument.isDown();
            }
        }).map(new AbstractFunction<Service, Incident>() {
            public Incident apply(Service arg) {
                return arg.getMostRecentIncident();
            }
        }).sortOn(new AbstractFunction<Incident, Integer>() {
            public Integer apply(Incident arg) {
                return arg.getPriority();
            }
        }).take(5).toList();
    }
+---- 

 Or event cleaner, if using {{{http://staccatocommons.sourceforge.net/staccatissimo/commonslambda/index.html}Staccato-Commons-Lambda}}:
 
+---
    Collection<Incident> getMostUrgentProblems3() {
        return Streams
            .from(services)
            .filter(lambda($(Service.class).isDown()))
            .map(lambda($(Service.class).getMostRecentIncident()))
            .sortOn(lambda($(Incident.class).getPriority()))
            .take(5)
            .toList();
    }
+---

* Examples 

** Filtering and mapping   

+---
    import static net.sf.staccatocommons.lang.Compare.*;
    import static net.sf.staccatocommons.lang.number.NumberTypes.*;
    
    //Answer a the next integers of those > 30 in the list
    Cons
     .from(20, 60, 9, 31, 26)
     .filter(greaterThan(30))
     .map(add(1));
+---

** Mapping and getting average

+---
    interface BusinessArea { BigDecimal getBucket(); }

    List<BusinessArea> businessAreas = ...;

   //Return the average bucket of the business areas
    Streams
     .from(businessAreas) //
     .map(lambda($(BusinessArea.class).getBucket()))
     .average();
+---

** Dropping and getting any element

+---
    interface Fruit {}
    class Apple implements Fruit {};
    Collection<Fruit> fruits = ...;
    
    //Answers any fruit, except of the first one.
    //If there is no fruit, or just one fruit element, 
    //returns a new Apple.
    Streams
      .from(fruits)
      .drop(1)
      .anyOrElse(new Apple());

+--

** Getting the Cartesian product and testing all elements

+---
    interface Buyer {
        boolean buys(Product product);
    }
    interface Product {}

    Collection<Product> products = ...;
    Collection<Buyer> buyers = ...;

    //Answers if all buyers can buy all the products
    Streams
      .from(buyers)
      .cross(Streams.from(products))
      .all(new Predicate<Pair<Buyer, Product>>() {
          public boolean eval(Pair<Buyer, Product> p) {
              return p.first().buys(p.second());
          }
      });

+---  

** Random access over streams with undefined elements

+---
 //Answers the third element of the stream [1/50,1/0,1/60,1/10].
 // Notice that second element is undefined - evaluating it would result in an ArithmeticException,
 // but thanks to stream laziness, the operation succeeds  
 Cons 
    .from(50, 0, 60, 10)
    .map(integer().inverse())
    .third();

+--- 

** Appending, FlatMapping and getting max element

+---
    interface Holding { 
        Collection<Company> getCompanies();
    }
    interface Company {
        BigDecimal getRevenue();
    }
    
    Collection<Holding> otherHoldings = ...;
    Holding thisHolding = ...;
    
    //Answer the company that has the highest revenue, among all the companies 
    //of thisHolding and otherHoldings
    Cons
        .from(thisHolding)
        .append(otherHoldings)
        .flatMap(lambda($(Holding.class).getCompanies()))
        .maximumOn(lambda($(Company.class).getRevenue()));
+---



 