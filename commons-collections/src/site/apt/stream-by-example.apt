Stream by example

* Introduction 
 
 Streams are potentially infinite iterable objects that have a very rich interface and
  perform most operations in a lazy manner and functional style.
  They are designed to make complex, lazy transformations on iterable 
  or iterable-like objects easier. Although they are primary targeted for dealing with collections, other Staccato-Commons
  projects offer other alternative implementations that extend their scope.  
  
  On the other hand, for performing simple, eager transformations on just iterables, eventually in a more imperative style, 
 have a look at {{{iterables-by-example.html}Iterables by example}}.
  
* The problem
  
  Quite frequently, developers need to perform in-memory complex, chained transformations over collections, like selecting,
  filtering or mapping elements. In Java, without any support for those operation neither at language nor standard library level, 
  developers have usually to implement them writing ad-hoc methods. Code like the following is far too common:
  
+---
   Collection<Incident> getMostUrgentProblems() {
        List<Incident> incidents = new ArrayList<Incident>();
        for (Service service : services) {
            if (service.isDown()) {
                incidents.add(service.getMostRecentIncident());
            }
        }
        Collections.sort(incidents, new Comparator<Incident>() {
            public int compare(Incident arg0, Incident arg1) {
                return arg0.getPriority() - arg1.getPriority();
            }
        });
        if (incidents.size() > 5) {
            for (Iterator<Incident> iter = incidents.listIterator(5); iter.hasNext();) {
                iter.next();
                iter.remove();
            }
        }
        return incidents;
    }
+--- 
 
  The problem of such code is that it is reinventing the wheel, mixing different transformations in one.  In this case, developer is
  filtering down services, mapping their most recent incidents, and getting top 5 most urgent issues by priority - 4 operations 
  that need to be coded, tested, and probably debugged. 
  
  Fortunately, many Java frameworks exists that attack those problems, each one with its pros and cons:
   {{{http://commons.apache.org/collections/}Apache Commons Collections}}, 
  {{{http://code.google.com/p/guava-libraries/}Guava (formerly Google Collections)}},
   {{{http://code.google.com/p/totallylazy/}TotallyLazy}},
  {{{http://functionaljava.org/}FunctionalJava}}, 
  {{{http://www.op4j.org/}Op4J}}, {{{http://quaere.codehaus.org/}Quaere}} 
  and of course, Staccato-Commons-Collections.
  
  It is not our intention to make a comparison between all those frameworks.
  As said before, all them have both strengths and flaws, and the developer should decide which fits better. 
  Instead, we will just present the solutions Staccato-Commons-Collections offers.
  
  
  
* The Solution

 Streams are the Staccato-Commons solution for performing such operations on iterables. They are generic wrappers that implement many of those
common transformation in a lazy manner - that is, no processing is actually performed in most cases unless it it actually necessary, which
enables them to perform efficiently chained operations on demand on both small and very large sequences of elements. They can be constructed  
literally by specifying their elements (Cons utility class), by specifying the elements generation strategy (Iterate utility class), 
by decorating other Iterables (Streams utility class) or using sources like databases result sets, directories, files, etc
 (provided by the rest of Staccato-Commons projects). 
 
 For example, the previous code can be refactored to use Streams:

+----
    Collection<Incident> getMostUrgentProblems2() {
        return Streams.from(services).filter(new Predicate<Service>() {
            public boolean eval(Service argument) {
                return argument.isDown();
            }
        }).map(new AbstractFunction<Service, Incident>() {
            public Incident apply(Service arg) {
                return arg.getMostRecentIncident();
            }
        }).sortOn(new AbstractFunction<Incident, Integer>() {
            public Integer apply(Incident arg) {
                return arg.getPriority();
            }
        }).take(5).toList();
    }
+---- 

 Or event cleaner, if using Staccato-Commons-Lambda:
 
+---
    Collection<Incident> getMostUrgentProblems3() {
        return Streams
            .from(services)
            .filter(lambda($(Service.class).isDown()))
            .map(lambda($(Service.class).getMostRecentIncident()))
            .sortOn(lambda($(Incident.class).getPriority()))
            .take(5)
            .toList();
    }
+---

* Examples 

** Filtering and mapping   

+---
    import static net.sf.staccatocommons.lang.Compare.*;
    import static net.sf.staccatocommons.lang.number.NumberTypes.*;
    
    //Answer a the next integers of those > 30 in the list
    Cons.from(20, 60, 9, 31, 26)
        .filter(greaterThan(30))
        .map(add(1));
+---

** Mapping and getting average

+---
    interface BusinessArea { BigDecimal getBucket(); }

    List<BusinessArea> businessAreas = ...;

   //Return the average bucket of the business areas
    Streams.from(businessAreas) //
        .map(lambda($(BusinessArea.class).getBucket()))
        .average();
+---

** Comparing elements

** FlatMapping and Zipping 

** Appending and accessing

** Appending undefined elements and getting size

** Getting max element

** Dropping and getting any element 

+---
    interface Fruit {}
    class Apple implements Fruit {};
    Collection<Fruit> fruits = ...;
    
    //Answers any fruit, except of the first one.
    //If there is no fruit, or just one fruit element, 
    //returns a new Apple.
    Streams.from(fruits)
               .drop(1)
               .anyOrElse(new Apple());

+--
 