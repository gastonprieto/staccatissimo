~~
~~  Copyright (c) 2011, The Staccato-Commons Team
~~
~~  This program is free software; you can redistribute it and/or modify
~~  it under the terms of the GNU Lesser General Public License as published by
~~  the Free Software Foundation; version 3 of the License.
~~
~~  This program is distributed in the hope that it will be useful,
~~  but WITHOUT ANY WARRANTY; without even the implied warranty of
~~  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
~~  GNU Lesser General Public License for more details.
~~

About Staccato-Commons-Lambda 
 
 Staccato-Commons-Lambda is a minimalistic and lightweight library for instantiating simple Staccato-Commond-Defs'
Functions and Evaluables in a DSL style, without using anonymous classes. This project is aimed to simplify higher-order programming 
within Staccato-Commons until Java adds lambdas to its language (planned for Java 8) 

Getting Started

 The entry point to Staccato-Commons-Lambda is the <<<Lambda>>> class, which allows to create functions in a concise and redable way. 
 There are two ways of using it, this introduction will just show one of them - using a shared lambda factory. The alternative, 
 more performant but a bit more verbose way - using local lambda factories - is discussed in the API docs. 
 
* Instantiating 1 argument functions    
 
 The simplest function to create are one argument functions. Without Staccato-Commons-Lambda, implementing such functions require to extend
 AbstractFunction. For example, a function that return book's ISBN looks like the following:
 
+---
  new AbstractFunction<Book, String>() {
    public String apply(@NonNull Book book){
        return book.getIsbn();
    }  
  };  
+--

 Which is OK, but is far from being the panacea. In particular, it is not too readable. This can be improved statically importing Lambda:

+--
  lambda($(Book.class).getIsbn()); 
+--- 
 
  Which, although is odd at first glance, is much more intention revealing.
   
  Functions that can be instantiated using this syntax are not restricted to getters, for example:

+---
  lambda($(List.class).size());  
  lambda($(List.class).contains("hello"));
  lambda($(List.class).get(2));
+--  
  

* Instantiating 2 and 3 arguments functions

  Creating instances of Function2 and Function3 is also quite simple. For example, the following code:
  
+----
  new AbstractFunction2<Book, WeightUnit, BigDecimal>(){
   public BigDecimal apply(Book book, WeightUnit unit) {
     return book.getWeigth(unit);
   }
  };
+---

  can be rewritten using lambdas:

+---
  lambda2($(Book.class).getWeight(_(WeightUnit.class));
+---  

     
  
  
  
  