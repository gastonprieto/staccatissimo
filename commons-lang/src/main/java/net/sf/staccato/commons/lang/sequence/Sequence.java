/*
 Copyright (c) 2010, The Staccato-Commons Team   
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation; version 3 of the License.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.
 */
package net.sf.staccato.commons.lang.sequence;

import java.util.Iterator;

import net.sf.staccato.commons.lang.Applicable;
import net.sf.staccato.commons.lang.Evaluable;
import net.sf.staccato.commons.lang.value.UnmodifiableObject;

/**
 * A {@link Sequence} is an {@link Iterable} object whose {@link Iterator},
 * starting with a seed value, retrieves elements generated by a
 * {@link Applicable}, until an {@link Evaluable} stop condition is satisfied.
 * 
 * @author flbulgarelli
 * 
 * @param <T>
 */
public class Sequence<T> extends UnmodifiableObject implements Iterable<T> {

	private static final long serialVersionUID = 8811454338704704525L;

	private final T seed;

	private final Applicable<T, T> generator;

	private final Evaluable<T> stopCondition;

	/**
	 * 
	 * Creates a new {@link Sequence}
	 * 
	 * @param seed
	 *          the initial value to be retrieved
	 * @param generator
	 * @param stopCondition
	 *          a predicate that evaluates to true when sequencing should stop,
	 *          that is, when the given element and subsequent should not be
	 *          retrieved.
	 */
	public Sequence(T seed, Applicable<T, T> generator, Evaluable<T> stopCondition) {
		this.seed = seed;
		this.generator = generator;
		this.stopCondition = stopCondition;
	}

	/**
	 * @return the start
	 */
	public T getSeed() {
		return seed;
	}

	/**
	 * @return the generator
	 */
	public Applicable<T, T> getGenerator() {
		return generator;
	}

	/**
	 * @return the stopCondition
	 */
	public Evaluable<T> getEvaluable() {
		return stopCondition;
	}

	@Override
	public Iterator<T> iterator() {
		return new Iterator<T>() {

			private T next = getSeed();

			@Override
			public boolean hasNext() {
				return !getEvaluable().eval(next);
			}

			@Override
			public T next() {
				T next = this.next;
				this.next = getGenerator().apply(next);
				return next;
			}

			@Override
			public void remove() {
				throw new UnsupportedOperationException("Unmodifiable interator");
			}
		};
	}

	public static <T> Sequence<T> from(T start, Applicable<T, T> generator,
		Evaluable<T> stopCondition) {
		return new Sequence<T>(start, generator, stopCondition);
	}

	public static Sequence<Integer> fromBy(int from, int step) {
		return new Sequence(
			from,
			new IntegerIncrement(step),
			StopConditions.stopNever());
	}

	public static Sequence<Integer> fromToBy(int from, int to, int step) {
		return new Sequence(
			from,
			new IntegerIncrement(step),
			step < 0 ? StopConditions.downTo(to) : StopConditions.upTo(to));
	}

	public static Sequence<Integer> fromTo(int from, int to) {
		return fromToBy(from, to, from < to ? 1 : -1);
	}

	public static Sequence<Integer> fromZeroTo(int to) {
		return fromToBy(0, to, 1);
	}

	public static Sequence<Integer> fromOneTo(int to) {
		return fromToBy(1, to, 1);
	}
}