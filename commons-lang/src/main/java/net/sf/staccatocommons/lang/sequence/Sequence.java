/**
 *  Copyright (c) 2011, The Staccato-Commons Team
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation; version 3 of the License.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 */

package net.sf.staccatocommons.lang.sequence;

import static net.sf.staccatocommons.lang.number.NumberTypes.*;
import static net.sf.staccatocommons.lang.sequence.StopConditions.*;

import java.io.Serializable;
import java.util.Iterator;
import java.util.NoSuchElementException;

import net.sf.staccatocommons.check.Ensure;
import net.sf.staccatocommons.defs.Applicable;
import net.sf.staccatocommons.defs.Evaluable;
import net.sf.staccatocommons.iterators.AbstractUnmodifiableIterator;
import net.sf.staccatocommons.lang.internal.ToString;
import net.sf.staccatocommons.restrictions.Conditionally;
import net.sf.staccatocommons.restrictions.check.NonNull;
import net.sf.staccatocommons.restrictions.value.Immutable;
import net.sf.staccatocommons.restrictions.value.Unmodifiable;

/**
 * A {@link Sequence} is an {@link Iterable} object whose {@link Iterator},
 * starting with a seed value, retrieves elements generated by a
 * {@link Applicable}, until an {@link Evaluable} stop condition is satisfied.
 * 
 * Sequences are {@link Unmodifiable}, and {@link Serializable}, but
 * serialization will not be sucessfull unless seed, generator and stopCondition
 * are serializable too.
 * 
 * @author flbulgarelli
 * 
 * @param <A>
 */
@Conditionally({ Immutable.class, Serializable.class })
public class Sequence<A> implements Iterable<A>, Serializable {

  private static final long serialVersionUID = 8811454338704704525L;

  private final A seed;

  private final Applicable<? super A, ? extends A> generator;

  private final Evaluable<? super A> stopCondition;

  /**
   * 
   * Creates a new {@link Sequence}
   * 
   * @param seed
   *          the initial value to be retrieved
   * @param generator
   *          a function used to generated each element from the sequence after
   *          the initial element
   * @param a
   *          predicate is satisfied when sequencing should stop, that is, when
   *          the given element and subsequent should not be retrieved.
   */
  public Sequence(A seed, @NonNull Applicable<? super A, ? extends A> generator,
    @NonNull Evaluable<? super A> stopCondition) {
    this.seed = seed;
    this.generator = generator;
    this.stopCondition = stopCondition;
  }

  /**
   * @return the initial value of the sequence
   */
  public A getSeed() {
    return seed;
  }

  /**
   * @return the generator of the sequence elements. Elements are generated
   *         applying the previous element of the sequence to the generator
   */
  @NonNull
  public Applicable<A, A> getGenerator() {
    return (Applicable<A, A>) generator;
  }

  /**
   * @return the stopCondition. Sequencing will continue until it evaluates to
   *         <code>true</code>
   */
  @NonNull
  public Evaluable<A> getStopCondition() {
    return (Evaluable<A>) stopCondition;
  }

  public String toString() {
    return ToString.toString(this);
  }

  /**
   * Returns an iterator that retrieves the values generated by
   * {@link #getGenerator()}, starting by {@link #getSeed()}, and until
   * {@link #getStopCondition()} evaluates to true.
   * 
   * There are therr particular cases of the previous definition:
   * <ul>
   * <li>An <em>infinite</em> iterator - if the stop condition is in practice
   * never met, that is, if this predicate evaluates to false always, or until
   * all system resources have been consumed</li>
   * <li>An <em>empty</em> iterator - if the stop condition is true for the seed
   * <li>A non-empty, finite iterator - if the stop condition is true for at
   * least one generated element, and false for the seed</li>
   * </ul>
   * 
   * @return a new sequencing iterator over the generated values
   */
  @Override
  public Iterator<A> iterator() {
    return new AbstractUnmodifiableIterator<A>() {
      private A next = getSeed();

      @Override
      public boolean hasNext() {
        return !stop();
      }

      private boolean stop() {
        return getStopCondition().eval(next);
      }

      @Override
      public A next() {
        if (stop())
          throw new NoSuchElementException();

        A next = this.next;
        this.next = getGenerator().apply(next);
        return next;
      }
    };
  }

  /**
   * Factory method for creating new {@link Sequence}.
   * 
   * For example, the following code:
   * 
   * <pre>
   * import static net.sf.staccatocommons.lang.sequence.StopConditions.*;
   * ...
   * Date march1 = ...;
   * Date march22 = ...; 
   * Function<Date,Date> nextWeek = ...;
   * Sequence.from( march1, nextWeek, upTo(march22) )
   * 
   * <pre>
   * 
   * will produce  a sequence that iterates through 1st of march, 8th of march, 15th of march and 22snd of march.
   *      
   * @param <A>
   * @param seed
   *          the initial element of the sequence
   * @param generator
   *          a function used to generated each element from the sequence after
   *          the initial element
   * @param stopCondition  a  
   *          predicate that is satisfied when sequencing should stop, that is, when
   *          the given element and subsequent should not be retrieved.
   * @return a new Sequence
   */
  @NonNull
  public static <A> Sequence<A> from(A seed, @NonNull Applicable<? super A, ? extends A> generator,
    @NonNull Evaluable<? super A> stopCondition) {
    return new Sequence<A>(seed, generator, stopCondition);
  }

  /**
   * Factory method that creates a new infinte {@link Sequence} that generates
   * integers applying an a positive, zero, or negative increment.
   * 
   * Zero step will produce a sequence that just replicates the seed.
   * 
   * @param from
   *          the seed of the sequence
   * @param step
   *          the positive, zero o negative increment
   * @return a new Sequence
   */
  @NonNull
  public static Sequence<Integer> fromBy(int from, int step) {
    return new Sequence(from, add(step), stopNever());
  }

  /**
   * Factory method that creates a new finite {@link Sequence} that generates
   * integers applying an a positive, or negative increment, until it reaches an
   * stop value.
   * 
   * For example <code>Sequence.fromToBy(0,4,1)</code> will iterate over 0,1,2,3
   * and 4.
   * 
   * @param from
   *          the seed of the sequence
   * @param to
   *          the stop value
   * @param step
   *          the positive or negative increment. Non zero.
   * @return a new Sequence
   */
  @NonNull
  public static Sequence<Integer> fromToBy(int from, int to, int step) {
    Ensure.that("step", step, step != 0, "must be non zero");
    return new Sequence(from, add(step), step < 0 ? downTo(to) : upTo(to));
  }

  /**
   * Factory method that creates a new finite {@link Sequence} that generates
   * integers incrementing or decrementing by one - depending on if the seed is
   * lower to the stop value or not, until it reaches an stop value.
   * 
   * For example <code>Sequence.fromTo(0,4)</code> will iterate over 0,1,2, 3
   * and 4, and <code>Sequence.fromTo(4,2)</code> will iterate over 4, 3 and 2.
   * 
   * @param from
   *          the seed of the sequence
   * @param to
   *          the stop value
   * @return a new Sequence
   */
  @NonNull
  public static Sequence<Integer> fromTo(int from, int to) {
    return fromToBy(from, to, from < to ? 1 : -1);
  }

}